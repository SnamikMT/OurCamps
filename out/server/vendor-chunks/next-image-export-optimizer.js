"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-image-export-optimizer";
exports.ids = ["vendor-chunks/next-image-export-optimizer"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js":
/*!************************************************************************!*\
  !*** ./node_modules/next-image-export-optimizer/dist/ExportedImage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/image */ \"(ssr)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst splitFilePath = ({ filePath })=>{\n    const filenameWithExtension = filePath.split(\"\\\\\").pop()?.split(\"/\").pop() || \"\";\n    const filePathWithoutFilename = filePath.split(filenameWithExtension).shift();\n    const fileExtension = filePath.split(\".\").pop();\n    const filenameWithoutExtension = filenameWithExtension.substring(0, filenameWithExtension.lastIndexOf(\".\")) || filenameWithExtension;\n    return {\n        path: filePathWithoutFilename,\n        filename: filenameWithoutExtension,\n        extension: fileExtension || \"\"\n    };\n};\nconst generateImageURL = (src, width, basePath, isRemoteImage = false)=>{\n    const { filename, path, extension } = splitFilePath({\n        filePath: src\n    });\n    const useWebp =  true ? \"true\" == \"true\" : 0;\n    if (![\n        \"JPG\",\n        \"JPEG\",\n        \"WEBP\",\n        \"PNG\",\n        \"AVIF\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        // The images has an unsupported extension\n        // We will return the src\n        return src;\n    }\n    // If the images are stored as WEBP by the package, then we should change\n    // the extension to WEBP to load them correctly\n    let processedExtension = extension;\n    if (useWebp && [\n        \"JPG\",\n        \"JPEG\",\n        \"PNG\",\n        \"GIF\"\n    ].includes(extension.toUpperCase())) {\n        processedExtension = \"WEBP\";\n    }\n    let correctedPath = path;\n    const lastChar = correctedPath?.substr(-1); // Selects the last character\n    if (lastChar != \"/\") {\n        // If the last character is not a slash\n        correctedPath = correctedPath + \"/\"; // Append a slash to it.\n    }\n    const isStaticImage = src.includes(\"_next/static/media\");\n    if (basePath) {\n        if (basePath.endsWith(\"/\") && correctedPath && correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + correctedPath.slice(1);\n        } else if (!basePath.endsWith(\"/\") && correctedPath && !correctedPath.startsWith(\"/\")) {\n            correctedPath = basePath + \"/\" + correctedPath;\n        } else {\n            correctedPath = basePath + correctedPath;\n        }\n    }\n    const exportFolderName = \"nextImageExportOptimizer\" || 0;\n    const basePathPrefixForStaticImages = basePath ? basePath + \"/\" : \"\";\n    let generatedImageURL = `${isStaticImage ? basePathPrefixForStaticImages : correctedPath}${exportFolderName}/${filename}-opt-${width}.${processedExtension.toUpperCase()}`;\n    // if the generatedImageURL is not starting with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && generatedImageURL.charAt(0) !== \"/\") {\n        generatedImageURL = \"/\" + generatedImageURL;\n    }\n    return generatedImageURL;\n};\n// Credits to https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\n// This is a hash function that is used to generate a hash from the image URL\nconst hashAlgorithm = (str, seed = 0)=>{\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\n    for(let i = 0, ch; i < str.length; i++){\n        ch = str.charCodeAt(i);\n        h1 = Math.imul(h1 ^ ch, 2654435761);\n        h2 = Math.imul(h2 ^ ch, 1597334677);\n    }\n    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);\n    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);\n    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);\n    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n};\nfunction urlToFilename(url) {\n    try {\n        const parsedUrl = new URL(url);\n        const extension = parsedUrl.pathname.split(\".\").pop();\n        if (extension) {\n            return hashAlgorithm(url).toString().concat(\".\", extension);\n        }\n    } catch (error) {\n        console.error(\"Error parsing URL\", url, error);\n    }\n    return hashAlgorithm(url).toString();\n}\nconst imageURLForRemoteImage = ({ src, width, basePath })=>{\n    const encodedSrc = urlToFilename(src);\n    return generateImageURL(encodedSrc, width, basePath, true);\n};\nconst optimizedLoader = ({ src, width, basePath })=>{\n    const isStaticImage = typeof src === \"object\";\n    const _src = isStaticImage ? src.src : src;\n    const originalImageWidth = isStaticImage && src.width || undefined;\n    // if it is a static image, we can use the width of the original image to generate a reduced srcset that returns\n    // the same image url for widths that are larger than the original image\n    if (isStaticImage && originalImageWidth && width > originalImageWidth) {\n        const deviceSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.deviceSizes || [\n            640,\n            750,\n            828,\n            1080,\n            1200,\n            1920,\n            2048,\n            3840\n        ]).map(Number);\n        const imageSizes = ({\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":true,\"domains\":[],\"remotePatterns\":[],\"output\":\"export\"}?.imageSizes || [\n            16,\n            32,\n            48,\n            64,\n            96,\n            128,\n            256,\n            384\n        ]).map(Number);\n        let allSizes = [\n            ...deviceSizes,\n            ...imageSizes\n        ];\n        allSizes = allSizes.filter((v, i, a)=>a.indexOf(v) === i);\n        allSizes.sort((a, b)=>a - b);\n        // only use the width if it is smaller or equal to the next size in the allSizes array\n        let nextLargestSize = null;\n        for(let i = 0; i < allSizes.length; i++){\n            if (Number(allSizes[i]) >= originalImageWidth && (nextLargestSize === null || Number(allSizes[i]) < nextLargestSize)) {\n                nextLargestSize = Number(allSizes[i]);\n            }\n        }\n        if (nextLargestSize !== null) {\n            return generateImageURL(_src, nextLargestSize, basePath);\n        }\n    }\n    // Check if the image is a remote image (starts with http or https)\n    if (_src.startsWith(\"http\")) {\n        return imageURLForRemoteImage({\n            src: _src,\n            width,\n            basePath\n        });\n    }\n    return generateImageURL(_src, width, basePath);\n};\nconst fallbackLoader = ({ src })=>{\n    let _src = typeof src === \"object\" ? src.src : src;\n    const isRemoteImage = _src.startsWith(\"http\");\n    // if the _src does not start with a slash, then we add one as long as it is not a remote image\n    if (!isRemoteImage && _src.charAt(0) !== \"/\") {\n        _src = \"/\" + _src;\n    }\n    return _src;\n};\nconst ExportedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ src, priority = false, loading, className, width, height, onLoad, unoptimized, placeholder = \"blur\", basePath = \"\", alt = \"\", blurDataURL, style, onError, overrideSrc, ...rest }, ref)=>{\n    const [imageError, setImageError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const automaticallyCalculatedBlurDataURL = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ExportedImage.useMemo[automaticallyCalculatedBlurDataURL]\": ()=>{\n            if (blurDataURL) {\n                // use the user provided blurDataURL if present\n                return blurDataURL;\n            }\n            // check if the src is specified as a local file -> then it is an object\n            const isStaticImage = typeof src === \"object\";\n            let _src = isStaticImage ? src.src : src;\n            if (unoptimized === true) {\n                // return the src image when unoptimized\n                return _src;\n            }\n            // Check if the image is a remote image (starts with http or https)\n            if (_src.startsWith(\"http\")) {\n                return imageURLForRemoteImage({\n                    src: _src,\n                    width: 10,\n                    basePath\n                });\n            }\n            // otherwise use the generated image of 10px width as a blurDataURL\n            return generateImageURL(_src, 10, basePath);\n        }\n    }[\"ExportedImage.useMemo[automaticallyCalculatedBlurDataURL]\"], [\n        blurDataURL,\n        src,\n        unoptimized,\n        basePath\n    ]);\n    // check if the src is a SVG image -> then we should not use the blurDataURL and use unoptimized\n    const isSVG = typeof src === \"object\" ? src.src.endsWith(\".svg\") : src.endsWith(\".svg\");\n    const [blurComplete, setBlurComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Currently, we have to handle the blurDataURL ourselves as the new Image component\n    // is expecting a base64 encoded string, but the generated blurDataURL is a normal URL\n    const blurStyle = placeholder === \"blur\" && !isSVG && automaticallyCalculatedBlurDataURL && automaticallyCalculatedBlurDataURL.startsWith(\"/\") && !blurComplete ? {\n        backgroundSize: style?.objectFit || \"cover\",\n        backgroundPosition: style?.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: `url(\"${automaticallyCalculatedBlurDataURL}\")`\n    } : undefined;\n    const isStaticImage = typeof src === \"object\";\n    let _src = isStaticImage ? src.src : src;\n    if (basePath && !isStaticImage && _src.startsWith(\"/\")) {\n        _src = basePath + _src;\n    }\n    if (basePath && !isStaticImage && !_src.startsWith(\"/\")) {\n        _src = basePath + \"/\" + _src;\n    }\n    // Memoize the loader function\n    const imageLoader = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ExportedImage.useMemo[imageLoader]\": ()=>{\n            return imageError || unoptimized === true ? ({\n                \"ExportedImage.useMemo[imageLoader]\": ()=>fallbackLoader({\n                        src: overrideSrc || src\n                    })\n            })[\"ExportedImage.useMemo[imageLoader]\"] : ({\n                \"ExportedImage.useMemo[imageLoader]\": (e)=>optimizedLoader({\n                        src,\n                        width: e.width,\n                        basePath\n                    })\n            })[\"ExportedImage.useMemo[imageLoader]\"];\n        }\n    }[\"ExportedImage.useMemo[imageLoader]\"], [\n        imageError,\n        unoptimized,\n        overrideSrc,\n        src,\n        basePath\n    ]);\n    const handleError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ExportedImage.useCallback[handleError]\": (error)=>{\n            setImageError(true);\n            setBlurComplete(true);\n            // execute the onError function if provided\n            onError && onError(error);\n        }\n    }[\"ExportedImage.useCallback[handleError]\"], [\n        onError\n    ]);\n    const handleLoad = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ExportedImage.useCallback[handleLoad]\": (e)=>{\n            // for some configurations, the onError handler is not called on an error occurrence\n            // so we need to check if the image is loaded correctly\n            const target = e.target;\n            if (target.naturalWidth === 0) {\n                // Broken image, fall back to unoptimized (meaning the original image src)\n                setImageError(true);\n            }\n            setBlurComplete(true);\n            // execute the onLoad callback if present\n            onLoad && onLoad(e);\n        }\n    }[\"ExportedImage.useCallback[handleLoad]\"], [\n        onLoad\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(next_image__WEBPACK_IMPORTED_MODULE_0__[\"default\"], {\n        ref: ref,\n        alt: alt,\n        ...rest,\n        ...width && {\n            width\n        },\n        ...height && {\n            height\n        },\n        ...loading && {\n            loading\n        },\n        ...className && {\n            className\n        },\n        ...onLoad && {\n            onLoad\n        },\n        ...overrideSrc && {\n            overrideSrc\n        },\n        ...placeholder && {\n            placeholder: blurStyle || blurComplete ? \"empty\" : placeholder\n        },\n        ...unoptimized && {\n            unoptimized\n        },\n        ...priority && {\n            priority\n        },\n        ...isSVG && {\n            unoptimized: true\n        },\n        style: {\n            ...style,\n            ...blurStyle\n        },\n        loader: imageLoader,\n        blurDataURL: automaticallyCalculatedBlurDataURL,\n        onError: handleError,\n        onLoad: handleLoad,\n        src: isStaticImage ? src : _src\n    });\n});\nExportedImage.displayName = \"ExportedImage\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportedImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1pbWFnZS1leHBvcnQtb3B0aW1pemVyL2Rpc3QvRXhwb3J0ZWRJbWFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzZEQUMrQjtBQUMyQztBQUMxRSxNQUFNTSxnQkFBZ0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7SUFDL0IsTUFBTUMsd0JBQXdCRCxTQUFTRSxLQUFLLENBQUMsTUFBTUMsR0FBRyxJQUFJRCxNQUFNLEtBQUtDLFNBQVM7SUFDOUUsTUFBTUMsMEJBQTBCSixTQUFTRSxLQUFLLENBQUNELHVCQUF1QkksS0FBSztJQUMzRSxNQUFNQyxnQkFBZ0JOLFNBQVNFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzdDLE1BQU1JLDJCQUEyQk4sc0JBQXNCTyxTQUFTLENBQUMsR0FBR1Asc0JBQXNCUSxXQUFXLENBQUMsU0FBU1I7SUFDL0csT0FBTztRQUNIUyxNQUFNTjtRQUNOTyxVQUFVSjtRQUNWSyxXQUFXTixpQkFBaUI7SUFDaEM7QUFDSjtBQUNBLE1BQU1PLG1CQUFtQixDQUFDQyxLQUFLQyxPQUFPQyxVQUFVQyxnQkFBZ0IsS0FBSztJQUNqRSxNQUFNLEVBQUVOLFFBQVEsRUFBRUQsSUFBSSxFQUFFRSxTQUFTLEVBQUUsR0FBR2IsY0FBYztRQUFFQyxVQUFVYztJQUFJO0lBQ3BFLE1BQU1JLFVBQVVDLEtBQXFFRyxHQUMvRUgsTUFBd0QsSUFBSSxTQUM1RCxDQUFJO0lBQ1YsSUFBSSxDQUFDO1FBQUM7UUFBTztRQUFRO1FBQVE7UUFBTztRQUFRO0tBQU0sQ0FBQ0ksUUFBUSxDQUFDWCxVQUFVWSxXQUFXLEtBQUs7UUFDbEYsMENBQTBDO1FBQzFDLHlCQUF5QjtRQUN6QixPQUFPVjtJQUNYO0lBQ0EseUVBQXlFO0lBQ3pFLCtDQUErQztJQUMvQyxJQUFJVyxxQkFBcUJiO0lBQ3pCLElBQUlNLFdBQ0E7UUFBQztRQUFPO1FBQVE7UUFBTztLQUFNLENBQUNLLFFBQVEsQ0FBQ1gsVUFBVVksV0FBVyxLQUFLO1FBQ2pF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QztRQUFHLEdBQUlpQixTQUFTO1lBQUVaLGFBQWE7UUFBSyxDQUFDO1FBQUdJLE9BQU87WUFBRSxHQUFHQSxLQUFLO1lBQUUsR0FBR1csU0FBUztRQUFDO1FBQUdjLFFBQVFQO1FBQWFuQixhQUFhUTtRQUFvQ04sU0FBU21CO1FBQWF6QixRQUFRMEI7UUFBWTlGLEtBQUtlLGdCQUFnQmYsTUFBTStDO0lBQUs7QUFDeFM7QUFDQWdCLGNBQWNvQyxXQUFXLEdBQUc7QUFDNUIsaUVBQWVwQyxhQUFhQSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGVsaXRhXFxEZXNrdG9wXFzQm9Cw0LPQtdGA0Y9cXE91ckNhbXBzXFxub2RlX21vZHVsZXNcXG5leHQtaW1hZ2UtZXhwb3J0LW9wdGltaXplclxcZGlzdFxcRXhwb3J0ZWRJbWFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiO1xuaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuY29uc3Qgc3BsaXRGaWxlUGF0aCA9ICh7IGZpbGVQYXRoIH0pID0+IHtcbiAgICBjb25zdCBmaWxlbmFtZVdpdGhFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIlxcXFxcIikucG9wKCk/LnNwbGl0KFwiL1wiKS5wb3AoKSB8fCBcIlwiO1xuICAgIGNvbnN0IGZpbGVQYXRoV2l0aG91dEZpbGVuYW1lID0gZmlsZVBhdGguc3BsaXQoZmlsZW5hbWVXaXRoRXh0ZW5zaW9uKS5zaGlmdCgpO1xuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBmaWxlUGF0aC5zcGxpdChcIi5cIikucG9wKCk7XG4gICAgY29uc3QgZmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gZmlsZW5hbWVXaXRoRXh0ZW5zaW9uLnN1YnN0cmluZygwLCBmaWxlbmFtZVdpdGhFeHRlbnNpb24ubGFzdEluZGV4T2YoXCIuXCIpKSB8fCBmaWxlbmFtZVdpdGhFeHRlbnNpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogZmlsZVBhdGhXaXRob3V0RmlsZW5hbWUsXG4gICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgIGV4dGVuc2lvbjogZmlsZUV4dGVuc2lvbiB8fCBcIlwiLFxuICAgIH07XG59O1xuY29uc3QgZ2VuZXJhdGVJbWFnZVVSTCA9IChzcmMsIHdpZHRoLCBiYXNlUGF0aCwgaXNSZW1vdGVJbWFnZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlbmFtZSwgcGF0aCwgZXh0ZW5zaW9uIH0gPSBzcGxpdEZpbGVQYXRoKHsgZmlsZVBhdGg6IHNyYyB9KTtcbiAgICBjb25zdCB1c2VXZWJwID0gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAgIT0gdW5kZWZpbmVkXG4gICAgICAgID8gcHJvY2Vzcy5lbnYubmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX3N0b3JlUGljdHVyZXNJbldFQlAgPT0gXCJ0cnVlXCJcbiAgICAgICAgOiB0cnVlO1xuICAgIGlmICghW1wiSlBHXCIsIFwiSlBFR1wiLCBcIldFQlBcIiwgXCJQTkdcIiwgXCJBVklGXCIsIFwiR0lGXCJdLmluY2x1ZGVzKGV4dGVuc2lvbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAvLyBUaGUgaW1hZ2VzIGhhcyBhbiB1bnN1cHBvcnRlZCBleHRlbnNpb25cbiAgICAgICAgLy8gV2Ugd2lsbCByZXR1cm4gdGhlIHNyY1xuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaW1hZ2VzIGFyZSBzdG9yZWQgYXMgV0VCUCBieSB0aGUgcGFja2FnZSwgdGhlbiB3ZSBzaG91bGQgY2hhbmdlXG4gICAgLy8gdGhlIGV4dGVuc2lvbiB0byBXRUJQIHRvIGxvYWQgdGhlbSBjb3JyZWN0bHlcbiAgICBsZXQgcHJvY2Vzc2VkRXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgIGlmICh1c2VXZWJwICYmXG4gICAgICAgIFtcIkpQR1wiLCBcIkpQRUdcIiwgXCJQTkdcIiwgXCJHSUZcIl0uaW5jbHVkZXMoZXh0ZW5zaW9uLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHByb2Nlc3NlZEV4dGVuc2lvbiA9IFwiV0VCUFwiO1xuICAgIH1cbiAgICBsZXQgY29ycmVjdGVkUGF0aCA9IHBhdGg7XG4gICAgY29uc3QgbGFzdENoYXIgPSBjb3JyZWN0ZWRQYXRoPy5zdWJzdHIoLTEpOyAvLyBTZWxlY3RzIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgIGlmIChsYXN0Q2hhciAhPSBcIi9cIikge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgbm90IGEgc2xhc2hcbiAgICAgICAgY29ycmVjdGVkUGF0aCA9IGNvcnJlY3RlZFBhdGggKyBcIi9cIjsgLy8gQXBwZW5kIGEgc2xhc2ggdG8gaXQuXG4gICAgfVxuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSBzcmMuaW5jbHVkZXMoXCJfbmV4dC9zdGF0aWMvbWVkaWFcIik7XG4gICAgaWYgKGJhc2VQYXRoKSB7XG4gICAgICAgIGlmIChiYXNlUGF0aC5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggJiZcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGguc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWJhc2VQYXRoLmVuZHNXaXRoKFwiL1wiKSAmJlxuICAgICAgICAgICAgY29ycmVjdGVkUGF0aCAmJlxuICAgICAgICAgICAgIWNvcnJlY3RlZFBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIFwiL1wiICsgY29ycmVjdGVkUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvcnJlY3RlZFBhdGggPSBiYXNlUGF0aCArIGNvcnJlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwb3J0Rm9sZGVyTmFtZSA9IHByb2Nlc3MuZW52Lm5leHRJbWFnZUV4cG9ydE9wdGltaXplcl9leHBvcnRGb2xkZXJOYW1lIHx8XG4gICAgICAgIFwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyXCI7XG4gICAgY29uc3QgYmFzZVBhdGhQcmVmaXhGb3JTdGF0aWNJbWFnZXMgPSBiYXNlUGF0aCA/IGJhc2VQYXRoICsgXCIvXCIgOiBcIlwiO1xuICAgIGxldCBnZW5lcmF0ZWRJbWFnZVVSTCA9IGAke2lzU3RhdGljSW1hZ2UgPyBiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyA6IGNvcnJlY3RlZFBhdGh9JHtleHBvcnRGb2xkZXJOYW1lfS8ke2ZpbGVuYW1lfS1vcHQtJHt3aWR0aH0uJHtwcm9jZXNzZWRFeHRlbnNpb24udG9VcHBlckNhc2UoKX1gO1xuICAgIC8vIGlmIHRoZSBnZW5lcmF0ZWRJbWFnZVVSTCBpcyBub3Qgc3RhcnRpbmcgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgZ2VuZXJhdGVkSW1hZ2VVUkwuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBnZW5lcmF0ZWRJbWFnZVVSTCA9IFwiL1wiICsgZ2VuZXJhdGVkSW1hZ2VVUkw7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZVVSTDtcbn07XG4vLyBDcmVkaXRzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9icnljL2NvZGUvYmxvYi9tYXN0ZXIvanNoYXNoL2V4cGVyaW1lbnRhbC9jeXJiNTMuanNcbi8vIFRoaXMgaXMgYSBoYXNoIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIGhhc2ggZnJvbSB0aGUgaW1hZ2UgVVJMXG5jb25zdCBoYXNoQWxnb3JpdGhtID0gKHN0ciwgc2VlZCA9IDApID0+IHtcbiAgICBsZXQgaDEgPSAweGRlYWRiZWVmIF4gc2VlZCwgaDIgPSAweDQxYzZjZTU3IF4gc2VlZDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2g7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaDEgPSBNYXRoLmltdWwoaDEgXiBjaCwgMjY1NDQzNTc2MSk7XG4gICAgICAgIGgyID0gTWF0aC5pbXVsKGgyIF4gY2gsIDE1OTczMzQ2NzcpO1xuICAgIH1cbiAgICBoMSA9IE1hdGguaW11bChoMSBeIChoMSA+Pj4gMTYpLCAyMjQ2ODIyNTA3KTtcbiAgICBoMSBePSBNYXRoLmltdWwoaDIgXiAoaDIgPj4+IDEzKSwgMzI2NjQ4OTkwOSk7XG4gICAgaDIgPSBNYXRoLmltdWwoaDIgXiAoaDIgPj4+IDE2KSwgMjI0NjgyMjUwNyk7XG4gICAgaDIgXj0gTWF0aC5pbXVsKGgxIF4gKGgxID4+PiAxMyksIDMyNjY0ODk5MDkpO1xuICAgIHJldHVybiA0Mjk0OTY3Mjk2ICogKDIwOTcxNTEgJiBoMikgKyAoaDEgPj4+IDApO1xufTtcbmZ1bmN0aW9uIHVybFRvRmlsZW5hbWUodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBwYXJzZWRVcmwucGF0aG5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzaEFsZ29yaXRobSh1cmwpLnRvU3RyaW5nKCkuY29uY2F0KFwiLlwiLCBleHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBVUkxcIiwgdXJsLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBoYXNoQWxnb3JpdGhtKHVybCkudG9TdHJpbmcoKTtcbn1cbmNvbnN0IGltYWdlVVJMRm9yUmVtb3RlSW1hZ2UgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRTcmMgPSB1cmxUb0ZpbGVuYW1lKHNyYyk7XG4gICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoZW5jb2RlZFNyYywgd2lkdGgsIGJhc2VQYXRoLCB0cnVlKTtcbn07XG5jb25zdCBvcHRpbWl6ZWRMb2FkZXIgPSAoeyBzcmMsIHdpZHRoLCBiYXNlUGF0aCwgfSkgPT4ge1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGNvbnN0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICBjb25zdCBvcmlnaW5hbEltYWdlV2lkdGggPSAoaXNTdGF0aWNJbWFnZSAmJiBzcmMud2lkdGgpIHx8IHVuZGVmaW5lZDtcbiAgICAvLyBpZiBpdCBpcyBhIHN0YXRpYyBpbWFnZSwgd2UgY2FuIHVzZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIGltYWdlIHRvIGdlbmVyYXRlIGEgcmVkdWNlZCBzcmNzZXQgdGhhdCByZXR1cm5zXG4gICAgLy8gdGhlIHNhbWUgaW1hZ2UgdXJsIGZvciB3aWR0aHMgdGhhdCBhcmUgbGFyZ2VyIHRoYW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgaWYgKGlzU3RhdGljSW1hZ2UgJiYgb3JpZ2luYWxJbWFnZVdpZHRoICYmIHdpZHRoID4gb3JpZ2luYWxJbWFnZVdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTPy5kZXZpY2VTaXplcyB8fCBbXG4gICAgICAgICAgICA2NDAsIDc1MCwgODI4LCAxMDgwLCAxMjAwLCAxOTIwLCAyMDQ4LCAzODQwLFxuICAgICAgICBdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgY29uc3QgaW1hZ2VTaXplcyA9IChwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUz8uaW1hZ2VTaXplcyB8fCBbXG4gICAgICAgICAgICAxNiwgMzIsIDQ4LCA2NCwgOTYsIDEyOCwgMjU2LCAzODQsXG4gICAgICAgIF0pLm1hcChOdW1iZXIpO1xuICAgICAgICBsZXQgYWxsU2l6ZXMgPSBbLi4uZGV2aWNlU2l6ZXMsIC4uLmltYWdlU2l6ZXNdO1xuICAgICAgICBhbGxTaXplcyA9IGFsbFNpemVzLmZpbHRlcigodiwgaSwgYSkgPT4gYS5pbmRleE9mKHYpID09PSBpKTtcbiAgICAgICAgYWxsU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICAvLyBvbmx5IHVzZSB0aGUgd2lkdGggaWYgaXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgbmV4dCBzaXplIGluIHRoZSBhbGxTaXplcyBhcnJheVxuICAgICAgICBsZXQgbmV4dExhcmdlc3RTaXplID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKE51bWJlcihhbGxTaXplc1tpXSkgPj0gb3JpZ2luYWxJbWFnZVdpZHRoICYmXG4gICAgICAgICAgICAgICAgKG5leHRMYXJnZXN0U2l6ZSA9PT0gbnVsbCB8fCBOdW1iZXIoYWxsU2l6ZXNbaV0pIDwgbmV4dExhcmdlc3RTaXplKSkge1xuICAgICAgICAgICAgICAgIG5leHRMYXJnZXN0U2l6ZSA9IE51bWJlcihhbGxTaXplc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRMYXJnZXN0U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSW1hZ2VVUkwoX3NyYywgbmV4dExhcmdlc3RTaXplLCBiYXNlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGlzIGEgcmVtb3RlIGltYWdlIChzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzKVxuICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHJldHVybiBpbWFnZVVSTEZvclJlbW90ZUltYWdlKHsgc3JjOiBfc3JjLCB3aWR0aCwgYmFzZVBhdGggfSk7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIHdpZHRoLCBiYXNlUGF0aCk7XG59O1xuY29uc3QgZmFsbGJhY2tMb2FkZXIgPSAoeyBzcmMgfSkgPT4ge1xuICAgIGxldCBfc3JjID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMgOiBzcmM7XG4gICAgY29uc3QgaXNSZW1vdGVJbWFnZSA9IF9zcmMuc3RhcnRzV2l0aChcImh0dHBcIik7XG4gICAgLy8gaWYgdGhlIF9zcmMgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHNsYXNoLCB0aGVuIHdlIGFkZCBvbmUgYXMgbG9uZyBhcyBpdCBpcyBub3QgYSByZW1vdGUgaW1hZ2VcbiAgICBpZiAoIWlzUmVtb3RlSW1hZ2UgJiYgX3NyYy5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIF9zcmMgPSBcIi9cIiArIF9zcmM7XG4gICAgfVxuICAgIHJldHVybiBfc3JjO1xufTtcbmNvbnN0IEV4cG9ydGVkSW1hZ2UgPSBmb3J3YXJkUmVmKCh7IHNyYywgcHJpb3JpdHkgPSBmYWxzZSwgbG9hZGluZywgY2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBvbkxvYWQsIHVub3B0aW1pemVkLCBwbGFjZWhvbGRlciA9IFwiYmx1clwiLCBiYXNlUGF0aCA9IFwiXCIsIGFsdCA9IFwiXCIsIGJsdXJEYXRhVVJMLCBzdHlsZSwgb25FcnJvciwgb3ZlcnJpZGVTcmMsIC4uLnJlc3QgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgW2ltYWdlRXJyb3IsIHNldEltYWdlRXJyb3JdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGJsdXJEYXRhVVJMKSB7XG4gICAgICAgICAgICAvLyB1c2UgdGhlIHVzZXIgcHJvdmlkZWQgYmx1ckRhdGFVUkwgaWYgcHJlc2VudFxuICAgICAgICAgICAgcmV0dXJuIGJsdXJEYXRhVVJMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgc3BlY2lmaWVkIGFzIGEgbG9jYWwgZmlsZSAtPiB0aGVuIGl0IGlzIGFuIG9iamVjdFxuICAgICAgICBjb25zdCBpc1N0YXRpY0ltYWdlID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgbGV0IF9zcmMgPSBpc1N0YXRpY0ltYWdlID8gc3JjLnNyYyA6IHNyYztcbiAgICAgICAgaWYgKHVub3B0aW1pemVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIHNyYyBpbWFnZSB3aGVuIHVub3B0aW1pemVkXG4gICAgICAgICAgICByZXR1cm4gX3NyYztcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW1hZ2UgaXMgYSByZW1vdGUgaW1hZ2UgKHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHMpXG4gICAgICAgIGlmIChfc3JjLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VVUkxGb3JSZW1vdGVJbWFnZSh7IHNyYzogX3NyYywgd2lkdGg6IDEwLCBiYXNlUGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBnZW5lcmF0ZWQgaW1hZ2Ugb2YgMTBweCB3aWR0aCBhcyBhIGJsdXJEYXRhVVJMXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUltYWdlVVJMKF9zcmMsIDEwLCBiYXNlUGF0aCk7XG4gICAgfSwgW2JsdXJEYXRhVVJMLCBzcmMsIHVub3B0aW1pemVkLCBiYXNlUGF0aF0pO1xuICAgIC8vIGNoZWNrIGlmIHRoZSBzcmMgaXMgYSBTVkcgaW1hZ2UgLT4gdGhlbiB3ZSBzaG91bGQgbm90IHVzZSB0aGUgYmx1ckRhdGFVUkwgYW5kIHVzZSB1bm9wdGltaXplZFxuICAgIGNvbnN0IGlzU1ZHID0gdHlwZW9mIHNyYyA9PT0gXCJvYmplY3RcIiA/IHNyYy5zcmMuZW5kc1dpdGgoXCIuc3ZnXCIpIDogc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0byBoYW5kbGUgdGhlIGJsdXJEYXRhVVJMIG91cnNlbHZlcyBhcyB0aGUgbmV3IEltYWdlIGNvbXBvbmVudFxuICAgIC8vIGlzIGV4cGVjdGluZyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZywgYnV0IHRoZSBnZW5lcmF0ZWQgYmx1ckRhdGFVUkwgaXMgYSBub3JtYWwgVVJMXG4gICAgY29uc3QgYmx1clN0eWxlID0gcGxhY2Vob2xkZXIgPT09IFwiYmx1clwiICYmXG4gICAgICAgICFpc1NWRyAmJlxuICAgICAgICBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMICYmXG4gICAgICAgIGF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwuc3RhcnRzV2l0aChcIi9cIikgJiZcbiAgICAgICAgIWJsdXJDb21wbGV0ZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplOiBzdHlsZT8ub2JqZWN0Rml0IHx8IFwiY292ZXJcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogc3R5bGU/Lm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybChcIiR7YXV0b21hdGljYWxseUNhbGN1bGF0ZWRCbHVyRGF0YVVSTH1cIilgLFxuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlzU3RhdGljSW1hZ2UgPSB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiO1xuICAgIGxldCBfc3JjID0gaXNTdGF0aWNJbWFnZSA/IHNyYy5zcmMgOiBzcmM7XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmIF9zcmMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgX3NyYyA9IGJhc2VQYXRoICsgX3NyYztcbiAgICB9XG4gICAgaWYgKGJhc2VQYXRoICYmICFpc1N0YXRpY0ltYWdlICYmICFfc3JjLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIF9zcmMgPSBiYXNlUGF0aCArIFwiL1wiICsgX3NyYztcbiAgICB9XG4gICAgLy8gTWVtb2l6ZSB0aGUgbG9hZGVyIGZ1bmN0aW9uXG4gICAgY29uc3QgaW1hZ2VMb2FkZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGltYWdlRXJyb3IgfHwgdW5vcHRpbWl6ZWQgPT09IHRydWVcbiAgICAgICAgICAgID8gKCkgPT4gZmFsbGJhY2tMb2FkZXIoeyBzcmM6IG92ZXJyaWRlU3JjIHx8IHNyYyB9KVxuICAgICAgICAgICAgOiAoZSkgPT4gb3B0aW1pemVkTG9hZGVyKHsgc3JjLCB3aWR0aDogZS53aWR0aCwgYmFzZVBhdGggfSk7XG4gICAgfSwgW2ltYWdlRXJyb3IsIHVub3B0aW1pemVkLCBvdmVycmlkZVNyYywgc3JjLCBiYXNlUGF0aF0pO1xuICAgIGNvbnN0IGhhbmRsZUVycm9yID0gdXNlQ2FsbGJhY2soKGVycm9yKSA9PiB7XG4gICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgLy8gZXhlY3V0ZSB0aGUgb25FcnJvciBmdW5jdGlvbiBpZiBwcm92aWRlZFxuICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoZXJyb3IpO1xuICAgIH0sIFtvbkVycm9yXSk7XG4gICAgY29uc3QgaGFuZGxlTG9hZCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIC8vIGZvciBzb21lIGNvbmZpZ3VyYXRpb25zLCB0aGUgb25FcnJvciBoYW5kbGVyIGlzIG5vdCBjYWxsZWQgb24gYW4gZXJyb3Igb2NjdXJyZW5jZVxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbWFnZSBpcyBsb2FkZWQgY29ycmVjdGx5XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0Lm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnJva2VuIGltYWdlLCBmYWxsIGJhY2sgdG8gdW5vcHRpbWl6ZWQgKG1lYW5pbmcgdGhlIG9yaWdpbmFsIGltYWdlIHNyYylcbiAgICAgICAgICAgIHNldEltYWdlRXJyb3IodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAvLyBleGVjdXRlIHRoZSBvbkxvYWQgY2FsbGJhY2sgaWYgcHJlc2VudFxuICAgICAgICBvbkxvYWQgJiYgb25Mb2FkKGUpO1xuICAgIH0sIFtvbkxvYWRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW1hZ2UsIHsgcmVmOiByZWYsIGFsdDogYWx0LCAuLi5yZXN0LCAuLi4od2lkdGggJiYgeyB3aWR0aCB9KSwgLi4uKGhlaWdodCAmJiB7IGhlaWdodCB9KSwgLi4uKGxvYWRpbmcgJiYgeyBsb2FkaW5nIH0pLCAuLi4oY2xhc3NOYW1lICYmIHsgY2xhc3NOYW1lIH0pLCAuLi4ob25Mb2FkICYmIHsgb25Mb2FkIH0pLCAuLi4ob3ZlcnJpZGVTcmMgJiYgeyBvdmVycmlkZVNyYyB9KSwgLi4uKHBsYWNlaG9sZGVyICYmIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBibHVyU3R5bGUgfHwgYmx1ckNvbXBsZXRlID8gXCJlbXB0eVwiIDogcGxhY2Vob2xkZXIsXG4gICAgICAgIH0pLCAuLi4odW5vcHRpbWl6ZWQgJiYgeyB1bm9wdGltaXplZCB9KSwgLi4uKHByaW9yaXR5ICYmIHsgcHJpb3JpdHkgfSksIC4uLihpc1NWRyAmJiB7IHVub3B0aW1pemVkOiB0cnVlIH0pLCBzdHlsZTogeyAuLi5zdHlsZSwgLi4uYmx1clN0eWxlIH0sIGxvYWRlcjogaW1hZ2VMb2FkZXIsIGJsdXJEYXRhVVJMOiBhdXRvbWF0aWNhbGx5Q2FsY3VsYXRlZEJsdXJEYXRhVVJMLCBvbkVycm9yOiBoYW5kbGVFcnJvciwgb25Mb2FkOiBoYW5kbGVMb2FkLCBzcmM6IGlzU3RhdGljSW1hZ2UgPyBzcmMgOiBfc3JjIH0pKTtcbn0pO1xuRXhwb3J0ZWRJbWFnZS5kaXNwbGF5TmFtZSA9IFwiRXhwb3J0ZWRJbWFnZVwiO1xuZXhwb3J0IGRlZmF1bHQgRXhwb3J0ZWRJbWFnZTtcbiJdLCJuYW1lcyI6WyJJbWFnZSIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZVN0YXRlIiwic3BsaXRGaWxlUGF0aCIsImZpbGVQYXRoIiwiZmlsZW5hbWVXaXRoRXh0ZW5zaW9uIiwic3BsaXQiLCJwb3AiLCJmaWxlUGF0aFdpdGhvdXRGaWxlbmFtZSIsInNoaWZ0IiwiZmlsZUV4dGVuc2lvbiIsImZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwicGF0aCIsImZpbGVuYW1lIiwiZXh0ZW5zaW9uIiwiZ2VuZXJhdGVJbWFnZVVSTCIsInNyYyIsIndpZHRoIiwiYmFzZVBhdGgiLCJpc1JlbW90ZUltYWdlIiwidXNlV2VicCIsInByb2Nlc3MiLCJlbnYiLCJuZXh0SW1hZ2VFeHBvcnRPcHRpbWl6ZXJfc3RvcmVQaWN0dXJlc0luV0VCUCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwidG9VcHBlckNhc2UiLCJwcm9jZXNzZWRFeHRlbnNpb24iLCJjb3JyZWN0ZWRQYXRoIiwibGFzdENoYXIiLCJzdWJzdHIiLCJpc1N0YXRpY0ltYWdlIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJleHBvcnRGb2xkZXJOYW1lIiwibmV4dEltYWdlRXhwb3J0T3B0aW1pemVyX2V4cG9ydEZvbGRlck5hbWUiLCJiYXNlUGF0aFByZWZpeEZvclN0YXRpY0ltYWdlcyIsImdlbmVyYXRlZEltYWdlVVJMIiwiY2hhckF0IiwiaGFzaEFsZ29yaXRobSIsInN0ciIsInNlZWQiLCJoMSIsImgyIiwiaSIsImNoIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJpbXVsIiwidXJsVG9GaWxlbmFtZSIsInVybCIsInBhcnNlZFVybCIsIlVSTCIsInBhdGhuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJlcnJvciIsImNvbnNvbGUiLCJpbWFnZVVSTEZvclJlbW90ZUltYWdlIiwiZW5jb2RlZFNyYyIsIm9wdGltaXplZExvYWRlciIsIl9zcmMiLCJvcmlnaW5hbEltYWdlV2lkdGgiLCJkZXZpY2VTaXplcyIsIl9fTkVYVF9JTUFHRV9PUFRTIiwibWFwIiwiTnVtYmVyIiwiaW1hZ2VTaXplcyIsImFsbFNpemVzIiwiZmlsdGVyIiwidiIsImEiLCJpbmRleE9mIiwic29ydCIsImIiLCJuZXh0TGFyZ2VzdFNpemUiLCJmYWxsYmFja0xvYWRlciIsIkV4cG9ydGVkSW1hZ2UiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJvbkxvYWQiLCJ1bm9wdGltaXplZCIsInBsYWNlaG9sZGVyIiwiYWx0IiwiYmx1ckRhdGFVUkwiLCJzdHlsZSIsIm9uRXJyb3IiLCJvdmVycmlkZVNyYyIsInJlc3QiLCJyZWYiLCJpbWFnZUVycm9yIiwic2V0SW1hZ2VFcnJvciIsImF1dG9tYXRpY2FsbHlDYWxjdWxhdGVkQmx1ckRhdGFVUkwiLCJpc1NWRyIsImJsdXJDb21wbGV0ZSIsInNldEJsdXJDb21wbGV0ZSIsImJsdXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwib2JqZWN0Rml0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwib2JqZWN0UG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZEltYWdlIiwiaW1hZ2VMb2FkZXIiLCJlIiwiaGFuZGxlRXJyb3IiLCJoYW5kbGVMb2FkIiwidGFyZ2V0IiwibmF0dXJhbFdpZHRoIiwiY3JlYXRlRWxlbWVudCIsImxvYWRlciIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-image-export-optimizer/dist/ExportedImage.js\n");

/***/ })

};
;